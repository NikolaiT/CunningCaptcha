Hey all!

In this article I will present you a very simple and in no sense 
optimized algorithm written in Python 3, which plots quadratic and cubic Bézier 
curves. I'll present two algorithms, let's call the first the direct approach, since it computes the corresponding x 
and y coordinates directly through the calculation of the equation. 
Another possibility is De Casteljau's algorithm, a recursive method. 
The general principle is illustrated <a 
href="http://en.wikipedia.org/wiki/De_Casteljau's_algorithm#Geometric_interpretation">here</a>. But the summarize the idea very briefly: If you want to compute the points of the Bézier curve, you subdivide the lines of the outer hull that are spanned from the n+1 control points [Where n denotes the dimension of the Bézier curve) at a ratio t (t goes from 0 to 1 in this process). If you connect the interpolation points, you'll obtain n-1 connected lines. Then you apply the exactly same principle to these new lines as before (recursive step), until you finally get only one line. Consider again the point at the ratio t on this single line left and BOOM you have the point on the Bézier curve for your specific t value. Inrease t and cointinue this process until you plotted the curve.
[PICTURE OF DE CASTLEJAUS PRINCIPLE HERE]
In this article, I'll supply source code snippets for both algorithms 
and will add a simple performance test to compare them.

But why do I even need such geometrical primitives? I am currently 
working on my captcha wordpress plugin, which builds the captcha from 
the ground up and therefore needs some mechanism to rasterize geometrical figures such as characters. Thus I need three different shapes: Simple lines, circles (or more generally ellipses) and lastly Bézier curves. I could compose rudimentary characters with just lines and circles but we have some ambition over here, don't we? 

This means that I will essentially define a new, but very primitive 
font. I guess that my font will contain around 10 to 15 glyphs and it will use a 
mezcla (mix) of bitmap and outline fonts techniques. If you want to know 
more about them, just <a 
href="http://en.wikipedia.org/wiki/Computer_font#Font_types">read it 
up</a>. I am going to publish a seperate post blog about this font 
project in the near future, so stay tuned. I am really exicted about 
how ugly and cruel this font will become (Actually that's an 
advantage for CAPTCHAS^^).

If you are further interested in the technical background knowledge and mathematical properties of Bézier splines, consider reading the <a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve">Wikipedia article</a> or <a href="http://pomax.github.io/bezierinfo/">this wonderful tutorial</a>! The authors of these articles explain the concepts ways better than a layman as I ever could. Here, I just present some simple code snippets to get started and wet the appetite.

Finally we see some actual code. This python script essentially draws quadratic and cubic Bézier curves. That's 
the direct approach as stated above.


[Crayon lang="Python"]
import tkinter
import math

class Bezier(tkinter.Canvas):
    '''
    Simple and slow algorithm to draw quadratic and 
    cubic Bézier curves. Heavily inspired by http://pomax.github.io/bezierinfo/#control
    This code should just prove a concept and is not intended to be 
    used in a real world app...
    Author: Nikolai Tschacher
    Date: 07.10.2013
    '''
    # Because Canvas doesn't support simple pixel plotting,
    # we need to help us out with a line with length 1 in
    # positive x direction.
    def plot_pixel(self, x0, y0):
        self.create_line(x0, y0, x0+1, y0)
        
    # Calculates the quadtratic Bézier polynomial for 
    # the n+1=3 coordinates.
    def quadratic_bezier_sum(self, t, w):
        t2 = t * t 
        mt = 1-t
        mt2 = mt * mt
        return w[0]*mt2 + w[1]*2*mt*t + w[2]*2
        
    # Calculates the cubic Bézier polynomial for 
    # the n+1=4 coordinates.
    def cubic_bezier_sum(self, t, w):
        t2 = t * t
        t3 = t2 * t
        mt = 1-t
        mt2 = mt * mt
        mt3 = mt2 * mt
        return w[0]*mt3 + 3*w[1]*mt2*t + 3*w[2]*mt*t2 + w[3]*t3

    def draw_quadratic_bez(self, p1, p2, p3):
        t = 0
        while (t < 1):
            x = self.quadratic_bezier_sum(t, (p1[0], p2[0], p3[0]))
            y = self.quadratic_bezier_sum(t, (p1[1], p2[1], p3[1]))
            self.plot_pixel(math.floor(x), math.floor(y))
            t += 0.001 # 1000 iterations. If you want the curve to be really
                       # fine grained, consider "t += 0.0001" for ten thousand iterations.
    
    def draw_cubic_bez(self, p1, p2, p3, p4):
        t = 0
        while (t < 1):
            x = self.cubic_bezier_sum(t, (p1[0], p2[0], p3[0], p4[0]))
            y = self.cubic_bezier_sum(t, (p1[1], p2[1], p3[1], p4[1]))
            self.plot_pixel(math.floor(x), math.floor(y))
            t += 0.001
    

if __name__ == '__main__':
	master = tkinter.Tk()
	w = Bezier(master, width=1000, height=1000)
	w.pack()

	# Finally draw some Bézier curves :)
	w.draw_quadratic_bez((70, 250), (62, 59), (250, 61))
	w.draw_quadratic_bez((170,77), (162, 159), (210, 161))
	w.draw_cubic_bez((120, 160), (35, 200), (153, 268), (165, 70))
	tkinter.mainloop()
[/Crayon]


And now De Casteljau’s algorithm. It's not limited to quadratic and 
cubic Bézier curves, on the contrary, you are free to plot curves of any degree n.

[Crayon lang="Python"]
import tkinter

class InvalidInputError(Exception):
    pass

class Casteljau(tkinter.Canvas):
    '''
    Implementation of de Casteljau's algorithm for drawing Bézier curves.
    Implemented along the submittal of http://pomax.github.io/bezierinfo/#control.
    Author: Nikolai Tschacher
    Date: 07.10.2013
    '''
    # Because Canvas doesn't support simple pixel plotting,
    # we need to help us out with a line with length 1 in
    # positive x direction.
    def plot_pixel(self, x0, y0):
        self.create_line(x0, y0, x0+1, y0)
        
    def draw_curve(self, points, t):
        # Check that input parameters are valid. We don't check wheter 
        # the elements in the tuples are of type int or float.
        for p in points:
            if (not isinstance(p, tuple) or not len(p) == 2):
                raise InvalidInputError('points is not a list of points(tuples)')
        if (len(points) == 1):
            self.plot_pixel(points[0][0], points[0][1])
        else:
            newpoints = []
            for i in range(0, len(points)-1):
                x = (1-t) * points[i][0] + t * points[i+1][0]
                y = (1-t) * points[i][1] + t * points[i+1][1]
                newpoints.append((x, y))
            self.draw_curve(newpoints, t)
    
    # Usage function for the algorithm.
    def draw(self, points):
        t = 0
        while (t <= 1):
            self.draw_curve(points, t)
            t += 0.001

if __name__ == '__main__':
	master = tkinter.Tk()
	w = Casteljau(master, width=1000, height=1000)
	w.pack()

	# Finally draw some Bézier curves :)
	w.draw([(70, 250), (62, 59), (250, 61)])
	w.draw([(133, 267), (121, 28), (198, 270), (210, 29)])
	tkinter.mainloop()
[/Crayon]

And finally the performance comparison between the two algorithms. The direct approach wins over De Casteljau’s algorithm (I guess because recursion is such a slowpoke), but on the other side De Casteljau's method is numerically stable. The direct approach is a little more than twice as fast! Note that the initial type checks in draw_curve() in class Casteljau were disabled while testing the speed to avoid contortions. I've shamelessly stolen the timing method from this site, using the following little class to time within <em>with</em> statements:
[Crayon lang="Python"]
import time

class Timer(object):
    def __init__(self, verbose=True):
        self.verbose = verbose

    def __enter__(self):
        self.start = time.time()
        return self

    def __exit__(self, *args):
        self.end = time.time()
        self.secs = self.end - self.start
        self.msecs = self.secs * 1000  # millisecs
        if self.verbose:
            print('elapsed time: %f ms' % self.msecs)
[/Crayon]

Eventually the source code for the performance tests:

[Crayon lang="Python"]
from timer import Timer
from bezier import Bezier # Simple bezier drawing algorithm directly derived from calculus.
from casteljau import Casteljau # Drawing curves using de Casteljau's algorithm.
import random

# Overwrite Bezier class and Casteljau class to disable the GUI functions. We just want to 
# mesure the algorithm's performance not the graphical toolkit overhead...

# Generate a pool of 1500 random points such that 500 quadratic bezier curves
# can be drawn.
NUMBER_OF_CURVES = 500

R = random.randrange
pp = [[(R(500), R(500)), (R(500), R(500)), (R(500), R(500))] for i in range(NUMBER_OF_CURVES)]

class BezierPerf(Bezier):
	def __init__(self):
		with Timer() as t:
			for points in pp:
				self.draw_quadratic_bez(points[0], points[1], points[2])
	def plot_pixel(self, x0, y0):
		pass # Nothin here oO

class CasteljauPerf(Casteljau):
	def __init__(self):
		with Timer() as t:
			for points in pp:
				self.draw(points)
	def plot_pixel(self, x0, y0):
		pass # No drawing please.

if __name__ == '__main__':
	test2 = CasteljauPerf()
	test = BezierPerf()

[/Crayon]


That's been it! I hope you learned something and please note this article might chance in the near future, so if you read this, you read a early version ;)
